# PLAN 17: Two-Layer Repackaging (Public Facade + Internal Core)

## Objective
Move from the current mixed monorepo packaging model to a two-layer layout that is easier to distribute and install from git, while preserving one consuming app project that can run as:
- Node CLI
- Browser app
- Tauri app

## Decisions locked for this plan
- Public consumer package name: `devalbo-cli` (only).
- Supported git install targets for consumers:
  - release tags only (`#vX.Y.Z`) as the guaranteed/stable consumer path
  - `main` branch is best-effort only (non-guaranteed)
- No scoped alias (`@devalbo-cli/cli`) in public docs/scripts/workflows.
- Release structure: publish-root model (CI-generated installable root on `release`).
- npm compatibility policy: matrix test install-paths on baseline npm + latest npm minor.

## Clarification: what “release branch structure” means
npm git installs resolve from the repository root `package.json` at the selected ref. They do not natively install a workspace subdirectory package as the root package.

This plan uses publish-root only:
- `release` branch root is a CI-generated publish tree (`package.json` + `README.md` + `dist/`) produced from `main`.
- release tags (`vX.Y.Z`) are created from explicit release commits on `release`.
- `main` installability is best-effort and not part of the guaranteed consumer contract.

## Metadata source of truth
- Canonical public package metadata lives at `packages/devalbo-cli/package.json`.
- Canonical public README lives at `packages/devalbo-cli/README.md` (or generated from a single source file).
- `release` publish-root is generated by CI from these canonical sources plus built `dist/`.
- Rule: never hand-edit package metadata directly on `release`; all changes flow from `main` via generation.
- CI must fail if generated publish-root metadata differs from canonical source definitions.

## CI baseline source of truth
- Canonical CI matrix baseline lives in `ci/repackaging-matrix.json` (tracked in git).
- File defines:
  - `node_baseline`
  - `node_active_lts`
  - `npm_baseline`
  - `npm_latest_minor`
- Workflows must read this file for matrix values (no duplicated hard-coded versions in workflow YAML).

## Constraints
- No breaking change to the current consumer API in early phases.
- Keep multi-surface app story intact during migration.
- Every phase must be shippable and CI-verifiable.

---

## Target architecture

### Layer 1: Public distribution package
- `packages/devalbo-cli` (only public entrypoint for consumers)
- Owns public exports map (`.`, `./vite`, etc.)
- Owns browser/node conditional resolution
- Owns dist artifact produced for git/release installs

### Layer 2: Internal core packages
- `packages/core-*` (or current packages renamed over time)
- Not referenced by external docs or consumer quickstarts
- Free to evolve internally as long as facade contract remains stable

---

## Migration strategy (incremental)

### Phase 0: Baseline and freeze (0.5 day)
- Capture current behavior matrix:
  - create-app smoke
  - CLI run
  - browser build/run
  - tauri build/run (sanity)
- Freeze public API surface snapshot from current `devalbo-cli`.
- Freeze package metadata contract:
  - `"name": "devalbo-cli"`
  - exports map keys and subpaths
  - install examples (`git+https://...`)

Exit criteria:
- Baseline runs recorded and reproducible.

### Phase 1: Introduce facade package without behavior change (1 day)
- Create/solidify `packages/devalbo-cli` as public facade package.
- Re-export existing public APIs from current internal modules.
- Keep package name and imports stable for consumers.
- Add CI guard: fail if public docs/scripts/workflows contain `@devalbo-cli/cli`.

Exit criteria:
- Existing external scaffold works unchanged.
- No API diffs in generated type declarations.

Rollback:
- Revert facade routing to prior internal entry and regenerate publish-root.

### Phase 2: Export boundary hardening (1 day)
- Define strict exports for facade package:
  - `.`
  - `./vite`
  - optional surface-specific subpaths only if needed
- Add browser/node conditions for `.`.
- Define expected export map contract in tests (exact keys + conditions).

Exit criteria:
- Vite resolves browser entry with no Node-only leakage.
- Node CLI path resolves Node entry.
- Browser artifact assertions pass:
  - no `createRequire` string
  - no `node:` builtin imports in browser entry/chunks
  - no unresolved `fs`/`path` in browser entry/chunks

Rollback:
- Keep default export path fallback in place until checks pass.

### Phase 3: Runtime split and import hygiene (1-2 days)
- Move platform-specific imports behind runtime-appropriate modules.
- Convert filesystem/runtime driver selection to dynamic import branches.
- Ensure createRequire/banner is node-only build concern.
- Add minimal Tauri compile smoke (can remain non-blocking in this phase, but must run).

Exit criteria:
- Browser build has no unresolved Node builtins for standard app scaffold.
- CLI runtime behavior unchanged.

### Phase 4: Build pipeline split (1 day)
- Build separate outputs for facade package:
  - `dist/node.js`
  - `dist/browser.js`
  - `dist/vite.js`
  - typings
- Ensure banner/config applied only to node target.
- Add artifact-level checks:
  - `dist/node.js` contains required node runtime paths
  - `dist/browser.js` excludes Node builtins
  - `dist/vite.js` imports are browser-build-safe

Exit criteria:
- Artifact inspection confirms clean separation.
- Import smoke passes for packed artifact and git install target.

### Phase 5: Distribution channel hardening (1 day)
- Establish release install target (`release` branch or tags) from facade package artifact.
- Release channel decision:
  - `main` install remains best-effort for latest consumer testing, not guaranteed.
  - CI produces publish-root on `release` branch (required).
  - Create immutable tags only from explicit release commits on `release` (`vX.Y.Z`) for consumer pinning.
- CI owns artifact update and integrity checks.
- Keep `main` developer-friendly; keep release install-friendly.

Release promotion protocol (required):
- Trigger: explicit maintainer-approved release workflow run from `main`.
- Inputs:
  - target version (`vX.Y.Z`)
  - source commit SHA on `main`
- Steps:
  1. Build publish-root artifact from source SHA.
  2. Run required CI gates (`release` + `tag` install-path matrix, runtime, contract checks).
  3. Fast-forward/update `release` branch to generated publish-root commit.
  4. Create immutable tag `vX.Y.Z` on that release commit.
- Approval:
  - at least one maintainer approval before tag creation.
- Rollback:
  - create a new corrective release commit/tag (do not mutate/delete published tags).
- Tag policy:
  - tags are immutable once published.

Exit criteria:
- `npm install git+...#release` works from clean temp dir with plain npm (pre-tag staging gate).
- `npm install git+...#vX.Y.Z` works from clean temp dir with plain npm.
- No npm auth requirement for public path.

### Phase 6: Docs, scripts, workflow convergence (0.5-1 day)
- Update `CREATE_AN_APP.md`, smoke scripts, and workflows to use facade package only.
- Remove legacy/scoped references from public docs.
- Ensure single consuming app scaffold includes CLI + browser + tauri guidance from same project.

Exit criteria:
- Copy/paste docs flow works end-to-end.

### Phase 7: Internal package rename to `core-*` (optional, 1-2 days)
- Rename internal packages to clarify they are non-public.
- Update workspace references.
- Keep facade exports unchanged.

Exit criteria:
- No external docs mention internal packages.
- All CI checks green.

---

## CI gates required

1. Install-path gates
- Git install from release ref in clean temp dir (staging verification; non-consumer guarantee).
- Git install from release tag (`vX.Y.Z`) in clean temp dir.
- Optional best-effort monitor: git install from `main` in clean temp dir (non-blocking).
- Local pack install/import smoke.
- All install-path jobs must run with sanitized npm environment:
  - unset token env vars
  - isolated user config
  - public registry explicitly set

2. Runtime gates
- CLI smoke command execution.
- Browser production build and minimal runtime mount test.
- Tauri build sanity (non-blocking in early phases, blocking by Phase 5).

3. Contract gates
- Public API/type snapshot diff check.
- Forbidden reference check in public docs/scripts (no internal package names).
- Dist artifact freshness/integrity checks.
- Package identity check:
  - root/install-target `package.json` name must be `devalbo-cli`.
- Export artifact checks:
  - browser entry/chunks do not contain Node-only imports
  - node entry contains expected node-only symbols from `packages/devalbo-cli/api-snapshots/node-symbol-allowlist.txt`

4. npm compatibility gates
- Run install-path gates on:
  - project baseline npm version
  - latest npm minor
- Required: both variants must pass before merge.
- Purpose: catch npm resolver regressions before users do.

5. Node runtime matrix gates
- Pin and run install-path gates on:
  - project baseline Node major (pinned exact, e.g. `24.x` current repo baseline)
  - active LTS Node major (pinned exact in workflow matrix)
- Required: all required install-path jobs (`release`, `tag`) must pass on both Node variants.
- `main` best-effort monitor can run on baseline Node only.

6. CI policy gates (required vs informational)
- Required/blocking:
  - install-path (`release`, `tag`) across Node/npm matrix
  - runtime gates (CLI, browser; Tauri blocking by Phase 5)
  - contract gates
- Informational/non-blocking:
  - `main` install monitor
- Maintainer ergonomics:
  - set explicit job timeouts
  - use concurrency cancellation for superseded PR runs
  - mark flaky informational jobs as non-blocking with clear annotation

---

## Risks and mitigations

Risk: Browser path accidentally pulls Node code.
- Mitigation: export-condition tests + browser bundle scan gate.

Risk: Facade introduces subtle API drift.
- Mitigation: declaration snapshot and command-level smoke tests.

Risk: Release channel drift.
- Mitigation: CI-owned release updates and scheduled verification.

Risk: Metadata drift between `packages/devalbo-cli` and generated `release` publish-root.
- Mitigation: generation-only writes + CI diff gate against canonical metadata.

Risk: Migration fatigue from big bang change.
- Mitigation: phase-by-phase rollout with rollback at each phase.

---

## Estimated effort
- Core path (Phases 0-6): ~3-6 working days.
- Optional internal rename (Phase 7): +1-2 days.

---

## Success criteria
- A single consuming app project can run CLI, browser, and tauri from one codebase.
- External install from git works with plain npm and no special flags.
- Public package boundary is explicit and stable.
- Internal package churn does not affect consumer install flows.

---

## Immediate next steps
0. Start from a dedicated Phase 0 branch and execute one phase per PR (no multi-phase PRs).
1. Approve public API snapshot list for facade package.
2. Implement Phase 1 facade hardening and package-name guardrails.
3. Add `ci/repackaging-matrix.json` and wire workflows to read versions from it.
4. Add CI skeleton workflow (`.github/workflows/repackaging-gates.yml`) with required vs informational jobs and TODO placeholders for phase wiring.
5. Implement release publish-root branch prototype in CI.
6. Add required install-path matrix gates (`release`, `tag`) with sanitized npm env across npm baseline + latest minor, plus non-blocking `main` monitor.
7. Proceed phase-by-phase with short PRs.

## API gate implementation details
- Snapshot source:
  - generated declaration bundle from facade package (`dist/**/*.d.ts`)
  - explicit export symbol manifest (machine-generated, required after Phase 2)
  - node symbol allowlist at `packages/devalbo-cli/api-snapshots/node-symbol-allowlist.txt` (required after Phase 2)
- Baseline location:
  - `packages/devalbo-cli/api-snapshots/` (tracked in git)
- Check command (example):
  - `pnpm -C packages/devalbo-cli run api:snapshot:check`
- Update command (maintainer only when intentional API change):
  - `pnpm -C packages/devalbo-cli run api:snapshot:update`
- PR requirement:
  - any snapshot change must include rationale in PR description (breaking/non-breaking classification).

## Initial tests to create
1. `tests/packaging/install-release-tag.test.sh`
- Creates temp dir, installs `git+https://...#vX.Y.Z`, imports required exports, exits non-zero on missing keys.

2. `tests/packaging/install-release-branch-staging.test.sh`
- Same as above but against `#release` (staging gate only).

3. `tests/packaging/main-install-monitor.test.sh`
- Non-blocking smoke install against `#main`.

4. `tests/packaging/browser-build-smoke.test.sh`
- Scaffolds minimal browser app, runs `vite build`, fails on unresolved Node builtins.

5. `tests/packaging/cli-runtime-smoke.test.sh`
- Scaffolds minimal CLI app, runs one command execution smoke path.

6. `tests/packaging/tauri-build-smoke.test.sh`
- Minimal Tauri compile sanity (non-blocking until Phase 5).

7. `tests/packaging/export-contract.test.ts`
- Validates `package.json` exports map keys/conditions exactly match contract.

8. `tests/packaging/artifact-scan.test.sh`
- Scans `dist/browser*` for forbidden Node-only markers (`createRequire`, `node:` imports, raw `fs`/`path`).

9. `tests/packaging/metadata-sync.test.sh`
- Verifies generated publish-root metadata matches canonical `packages/devalbo-cli` sources.
